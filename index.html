<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marin AI - Your Visual Conversation Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .switch-checkbox:checked + .switch-label .switch-toggle {
            transform: translateX(1.5rem);
        }
        #webcam-video {
            background-color: #e5e7eb; /* Gray background for video placeholder */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div id="app-container" class="bg-white shadow-2xl rounded-3xl p-6 md:p-10 w-full max-w-5xl text-gray-800">
        <h1 class="text-4xl md:text-5xl font-extrabold text-center mb-6 leading-tight text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600">
            Marin AI Assistant
        </h1>
        <p class="text-center text-lg md:text-xl text-gray-600 mb-8 font-medium">
            Engage your life through video conversation.
        </p>

        <div class="flex flex-col lg:flex-row space-y-8 lg:space-y-0 lg:space-x-8">
            <div class="flex-1 flex flex-col items-center">
                <video id="webcam-video" autoplay playsinline class="rounded-2xl shadow-xl w-full mb-6 max-h-96 object-cover"></video>
                <div id="log-container" class="bg-gray-50 border border-gray-300 rounded-2xl p-4 h-48 w-full overflow-y-auto mb-4 hidden">
                    <p id="log" class="text-sm text-gray-600 leading-relaxed"></p>
                </div>
            </div>

            <div class="flex-1 space-y-6">
                <div id="controls-section" class="space-y-6">
                    <div>
                        <label for="voice-select" class="block text-sm font-semibold text-gray-700 mb-2">Select your favorite voice:</label>
                        <select id="voice-select" class="block w-full px-4 py-3 rounded-xl border-2 border-gray-300 bg-gray-50 focus:border-blue-500 focus:ring focus:ring-blue-200 focus:ring-opacity-50 transition-colors duration-200 cursor-pointer">
                            <option value="puck">Puck</option>
                            <option value="kore">Kore</option>
                            <option value="fenrir">Fenrir</option>
                            <option value="charon">Charon</option>
                            <option value="aoede">Aoede</option>
                        </select>
                    </div>

                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <label id="camera-switch-label" for="camera-switch" class="flex items-center cursor-pointer text-gray-700 font-semibold">Share your camera (Off)</label>
                            <div class="relative">
                                <input type="checkbox" id="camera-switch" role="switch" aria-checked="false" aria-label="Toggle camera" class="sr-only switch-checkbox">
                                <div class="block bg-gray-300 w-14 h-8 rounded-full"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition switch-toggle"></div>
                            </div>
                        </div>

                        <button id="switch-camera-button" class="w-full px-6 py-3 rounded-full bg-indigo-500 text-white font-semibold shadow transition-all duration-300 transform hover:scale-105 hover:bg-indigo-600 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50" disabled>
                            Switch to Back Camera
                        </button>
                    </div>

                    <div class="flex items-center space-x-2 hidden" id="user-input-section">
                        <input type="text" id="prompt-input" placeholder="Type your prompt here..." class="flex-1 px-4 py-3 rounded-xl border-2 border-gray-300 focus:border-blue-500 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                        <button id="send-button" class="px-6 py-3 rounded-full bg-blue-600 text-white font-bold shadow-md transition-all duration-300 transform hover:scale-105 hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                            Send
                        </button>
                    </div>

                    <button id="mute-button" class="w-full px-6 py-3 rounded-full bg-yellow-500 text-white font-semibold shadow transition-all duration-300 transform hover:scale-105 hover:bg-yellow-600 focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50 hidden" aria-label="Mute microphone">
                        Mute Microphone
                    </button>

                    <button id="start-call-button" class="w-full px-6 py-4 rounded-full text-white font-bold text-lg shadow-lg transition-all duration-300 transform hover:scale-105 bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50">
                        Start Video Call
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // -- Constants and Global State --
        const API_KEY = "AIzaSyC2Fsjk3yCRA8hDVYgg5LlMn4sxwoJJaWU";
        const GEMINI_LIVE_ENDPOINT = `wss://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?key=${API_KEY}`;
        const RECONNECT_INTERVAL = 5000; // 5 seconds for reconnection attempts
        const MAX_RECONNECT_ATTEMPTS = 3;

        const state = {
            isCallActive: false,
            isMuted: false,
            isCameraOn: false,
            isFrontCamera: true,
            webSocket: null,
            mediaStream: null,
            audioContext: null,
            audioSource: null,
            scriptProcessorNode: null,
            reconnectAttempts: 0,
        };

        // -- DOM Element References --
        const elements = {
            startCallButton: document.getElementById('start-call-button'),
            controlsSection: document.getElementById('controls-section'),
            voiceSelect: document.getElementById('voice-select'),
            cameraSwitch: document.getElementById('camera-switch'),
            cameraSwitchLabel: document.getElementById('camera-switch-label'),
            switchCameraButton: document.getElementById('switch-camera-button'),
            muteButton: document.getElementById('mute-button'),
            userInputSection: document.getElementById('user-input-section'),
            promptInput: document.getElementById('prompt-input'),
            sendButton: document.getElementById('send-button'),
            videoElement: document.getElementById('webcam-video'),
            logContainer: document.getElementById('log-container'),
            logElement: document.getElementById('log'),
        };

        // -- Utility Functions --

        /**
         * Displays a Toastify notification.
         * @param {string} message - The message to display.
         * @param {string} color - The background color for the toast.
         */
        function showToast(message, color) {
            Toastify({
                text: message,
                duration: 3000,
                close: false,
                gravity: "bottom",
                position: "center",
                backgroundColor: color,
                stopOnFocus: true,
            }).showToast();
        }

        /**
         * Sanitizes user input to prevent XSS.
         * @param {string} input - The input string to sanitize.
         * @returns {string} - The sanitized string.
         */
        function sanitizeInput(input) {
            const div = document.createElement('div');
            div.textContent = input;
            return div.innerHTML;
        }

        /**
         * Converts raw PCM audio data into a WAV Blob.
         * @param {Int16Array} pcmData - The PCM audio data.
         * @param {number} sampleRate - The sample rate.
         * @returns {Blob} - The WAV audio blob.
         */
        function pcmToWav(pcmData, sampleRate) {
            const dataLength = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            let offset = 44;
            for (let i = 0; i < pcmData.length; i++, offset += 2) {
                view.setInt16(offset, pcmData[i], true);
            }
            return new Blob([buffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        /**
         * Plays PCM audio using the Web Audio API.
         * @param {ArrayBuffer} audioBuffer - The audio buffer to play.
         * @param {number} sampleRate - The sample rate of the audio.
         */
        let audioQueue = [];
        let isPlaying = false;
        async function playPcmAudio(audioBuffer, sampleRate = 16000) {
            audioQueue.push({ buffer: audioBuffer, sampleRate });
            if (!isPlaying) {
                processAudioQueue();
            }
        }

        async function processAudioQueue() {
            if (audioQueue.length === 0 || isPlaying) {
                return;
            }

            isPlaying = true;
            const { buffer, sampleRate } = audioQueue.shift();
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });

            try {
                const audioData = await audioCtx.decodeAudioData(buffer);
                const source = audioCtx.createBufferSource();
                source.buffer = audioData;
                source.connect(audioCtx.destination);
                source.onended = () => {
                    audioCtx.close();
                    isPlaying = false;
                    processAudioQueue();
                };
                source.start(0);
            } catch (e) {
                console.error("Error decoding audio data:", e);
                showToast("Error playing audio response.", "bg-red-500");
                isPlaying = false;
                processAudioQueue();
            }
        }

        /**
         * Converts Base64 string to an ArrayBuffer.
         * @param {string} base64 - The Base64-encoded string.
         * @returns {ArrayBuffer} - The decoded ArrayBuffer.
         */
        function base64ToArrayBuffer(base64) {
            try {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (e) {
                console.error("Error decoding Base64:", e);
                showToast("Invalid audio data received.", "bg-red-500");
                return null;
            }
        }

        /**
         * Initializes audio recording using the Web Audio API.
         */
        function initAudioRecording() {
            if (!state.mediaStream) {
                console.error("No media stream available for recording.");
                showToast("No media stream available for recording.", "bg-red-500");
                return false;
            }

            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                state.audioSource = state.audioContext.createMediaStreamSource(state.mediaStream);
                state.scriptProcessorNode = state.audioContext.createScriptProcessor(4096, 1, 1);

                state.scriptProcessorNode.onaudioprocess = (e) => {
                    if (state.isCallActive && !state.isMuted && state.webSocket?.readyState === WebSocket.OPEN) {
                        const inputBuffer = e.inputBuffer.getChannelData(0);
                        const pcm16 = new Int16Array(inputBuffer.length);
                        for (let i = 0; i < inputBuffer.length; i++) {
                            pcm16[i] = Math.max(-1, Math.min(1, inputBuffer[i])) * 0x7FFF;
                        }
                        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(pcm16.buffer)));
                        const payload = {
                            contents: [{
                                parts: [{
                                    inlineData: {
                                        mimeType: "audio/x-raw;rate=16000",
                                        data: base64Audio,
                                    },
                                }],
                            }],
                        };
                        state.webSocket.send(JSON.stringify(payload));
                    }
                };

                state.audioSource.connect(state.scriptProcessorNode);
                state.scriptProcessorNode.connect(state.audioContext.destination);
                return true;
            } catch (e) {
                console.error("Error initializing audio recording:", e);
                showToast("Failed to initialize audio recording.", "bg-red-500");
                return false;
            }
        }

        /**
         * Stops audio recording and cleans up resources.
         */
        function stopAudioRecording() {
            try {
                if (state.scriptProcessorNode) {
                    state.scriptProcessorNode.disconnect();
                    state.scriptProcessorNode = null;
                }
                if (state.audioSource) {
                    state.audioSource.disconnect();
                    state.audioSource = null;
                }
                if (state.audioContext) {
                    state.audioContext.close().catch((e) => console.error("Error closing audio context:", e));
                    state.audioContext = null;
                }
            } catch (e) {
                console.error("Error stopping audio recording:", e);
                showToast("Error stopping audio recording.", "bg-red-500");
            }
        }

        /**
         * Cleans up all resources (media stream, WebSocket, audio).
         */
        function cleanupResources() {
            try {
                if (state.webSocket) {
                    state.webSocket.close();
                    state.webSocket = null;
                }
                if (state.mediaStream) {
                    state.mediaStream.getTracks().forEach((track) => track.stop());
                    state.mediaStream = null;
                }
                stopAudioRecording();
                state.isCallActive = false;
                state.isCameraOn = false;
                state.isMuted = false;
                state.reconnectAttempts = 0;
                elements.logElement.textContent = '';
                updateUI();
                showToast("Session ended.", "bg-red-500");
            } catch (e) {
                console.error("Error cleaning up resources:", e);
                showToast("Error cleaning up session.", "bg-red-500");
            }
        }

        // -- Main Application Logic --

        /**
         * Updates the UI based on the current state.
         */
        function updateUI() {
            elements.startCallButton.textContent = state.isCallActive ? 'End Call' : 'Start Video Call';
            elements.startCallButton.classList.toggle('bg-green-600', !state.isCallActive);
            elements.startCallButton.classList.toggle('hover:bg-green-700', !state.isCallActive);
            elements.startCallButton.classList.toggle('bg-red-600', state.isCallActive);
            elements.startCallButton.classList.toggle('hover:bg-red-700', state.isCallActive);

            elements.cameraSwitchLabel.textContent = `Share your camera (${state.isCameraOn ? 'On' : 'Off'})`;
            elements.cameraSwitch.checked = state.isCameraOn;
            elements.cameraSwitch.setAttribute('aria-checked', state.isCameraOn);

            elements.switchCameraButton.textContent = state.isFrontCamera ? 'Switch to Back Camera' : 'Switch to Front Camera';
            elements.switchCameraButton.disabled = !state.isCameraOn;

            elements.muteButton.classList.toggle('hidden', !state.isCallActive);
            elements.userInputSection.classList.toggle('hidden', !state.isCallActive);
            elements.logContainer.classList.toggle('hidden', !state.isCallActive);

            if (state.isCameraOn && state.mediaStream) {
                elements.videoElement.srcObject = state.mediaStream;
            } else {
                elements.videoElement.srcObject = null;
            }
        }

        /**
         * Requests media permissions.
         * @param {Object} constraints - The media constraints.
         * @returns {MediaStream|null} - The media stream or null if failed.
         */
        async function requestPermissions(constraints) {
            try {
                return await navigator.mediaDevices.getUserMedia(constraints);
            } catch (err) {
                console.error("Error accessing media devices:", err);
                showToast(`Error accessing media devices: ${err.message}`, 'bg-red-500');
                return null;
            }
        }

        /**
         * Toggles the video call state.
         */
        async function toggleCall() {
            if (state.isCallActive) {
                cleanupResources();
            } else {
                elements.startCallButton.disabled = true;
                elements.startCallButton.textContent = 'Connecting...';
                showToast('Connecting to Marin AI...', 'bg-blue-500');

                const constraints = {
                    audio: true,
                    video: state.isCameraOn ? { facingMode: state.isFrontCamera ? 'user' : 'environment' } : false,
                };

                state.mediaStream = await requestPermissions(constraints);
                if (!state.mediaStream) {
                    elements.startCallButton.disabled = false;
                    elements.startCallButton.textContent = 'Start Video Call';
                    return;
                }

                if (initAudioRecording()) {
                    await connectWebSocket();
                } else {
                    cleanupResources();
                    elements.startCallButton.disabled = false;
                    elements.startCallButton.textContent = 'Start Video Call';
                }
            }
        }

        /**
         * Establishes WebSocket connection to Gemini Live API with reconnection logic.
         */
        async function connectWebSocket() {
            state.webSocket = new WebSocket(GEMINI_LIVE_ENDPOINT);

            state.webSocket.onopen = () => {
 
